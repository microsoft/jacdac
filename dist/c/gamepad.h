// Autogenerated C header file for Gamepad
#ifndef _JACDAC_SPEC_GAMEPAD_H
#define _JACDAC_SPEC_GAMEPAD_H 1

#define JD_SERVICE_CLASS_GAMEPAD  0x108f7456

// enum Buttons (uint32_t)
#define JD_GAMEPAD_BUTTONS_LEFT 0x1
#define JD_GAMEPAD_BUTTONS_UP 0x2
#define JD_GAMEPAD_BUTTONS_RIGHT 0x4
#define JD_GAMEPAD_BUTTONS_DOWN 0x8
#define JD_GAMEPAD_BUTTONS_A 0x10
#define JD_GAMEPAD_BUTTONS_B 0x20
#define JD_GAMEPAD_BUTTONS_MENU 0x40
#define JD_GAMEPAD_BUTTONS_SELECT 0x80
#define JD_GAMEPAD_BUTTONS_RESET 0x100
#define JD_GAMEPAD_BUTTONS_EXIT 0x200
#define JD_GAMEPAD_BUTTONS_X 0x400
#define JD_GAMEPAD_BUTTONS_Y 0x800

// enum Variant (uint8_t)
#define JD_GAMEPAD_VARIANT_THUMB 0x1
#define JD_GAMEPAD_VARIANT_ARCADE_BALL 0x2
#define JD_GAMEPAD_VARIANT_ARCADE_STICK 0x3
#define JD_GAMEPAD_VARIANT_GAMEPAD 0x4

/**
 * If the gamepad is analog, the directional buttons should be "simulated", based on gamepad position
 * (`Left` is `{ x = -1, y = 0 }`, `Up` is `{ x = 0, y = -1}`).
 * If the gamepad is digital, then each direction will read as either `-1`, `0`, or `1` (in fixed representation).
 * The primary button on the gamepad is `A`.
 */
#define JD_GAMEPAD_REG_DIRECTION JD_REG_READING
typedef struct jd_gamepad_direction {
    uint32_t buttons;  // Buttons
    int16_t x;  // ratio i1.15
    int16_t y;  // ratio i1.15
} jd_gamepad_direction_t;


/**
 * Constant Variant (uint8_t). The type of physical gamepad.
 */
#define JD_GAMEPAD_REG_VARIANT JD_REG_VARIANT

/**
 * Constant Buttons (uint32_t). Indicates a bitmask of the buttons that are mounted on the gamepad.
 * If the `Left`/`Up`/`Right`/`Down` buttons are marked as available here, the gamepad is digital.
 * Even when marked as not available, they will still be simulated based on the analog gamepad.
 */
#define JD_GAMEPAD_REG_BUTTONS_AVAILABLE 0x180

/**
 * Argument: buttons Buttons (uint32_t). Emitted whenever the state of buttons changes.
 */
#define JD_GAMEPAD_EV_BUTTONS_CHANGED JD_EV_CHANGE

#endif
