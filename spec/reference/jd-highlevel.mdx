# JACDAC

JACDAC stands for Joint Asynchronous Communication; Device Agnostic Control and it is a new protocol designed to make it easier for people to connect low cost microcontrollers and sensors together. JACDAC is not only designed for easier physical connectivity, it is an entire software stack that bridges the world of the low cost microcontroller to the web browser and beyond.

## Motivation

For the longest time, microcontroller programming remained out of reach for the majority. Traditionally, embedded developers, with comprehensive knowledge of toolchains and software development practices, have been required to write programs for microcontrollers. But over the past decade, this has changed. Now all it takes to program a microcontroller is to load up a web-based environment like [Microsoft MakeCode](https://makecode.com), build your program using colourful visual blocks, and download the resulting program to your microcontroller. It is so easy _[everyone is doing it](https://cacm.acm.org/magazines/2020/3/243028-the-bbc-microbit-from-the-u-k-to-the-world/fulltext)_.

Though microcontroller programming has become easier, compared to the easy experience of connecting a device to a personal computer, it still remains a challenge to connect additional peripherals and sensors to microcontrollers. Here, an understanding of electronics and low level communications protocols are required, which means that again, only embedded developers can successfully do it. Of course, there are many instances of ecosystems and special connectors that have emerged to solve the complexity of connecting electronics. Arduino Shields, Raspberry Pi HATs, and the micro:bit edge connector, all make it easier for non-experts to connect additional hardware to microcontrollers. This style of connector however is often non-compositional and impractical where specific form factors are required. To give more physical flexibility, wired connectors and modular ecosystems are used instead. Grove, Stemma QT, and Gadgeteer all use easy to connect cables to make it easier to compose hardware. But there are additional constraints that only become apparent when communicating with newly connected hardware.

The changing use of microcontrollers by non-experts, means that now the wired communications protocols of the past in the 1980s are hindering the developers of the future. For example: I2C does not support having more than one controller on the bus at a time; I2C does not support multiples of the same sensor on a bus without additional hardware configuration; SPI requires an additional select line for each sensor/peripheral that is connected to the microcontroller; and moreover, each sensor is near-guaranteed to have different software interfaces even those with the same functionality. These are just a few examples of subtleties that make connecting additional peripherals to microcontrollers a hard-frought experience. <!-- of protocol addressing, specialised software interfaces, implied electrical connectivity, and constraints on physical topology -->

What we set out to achieve with JACDAC is to remove all of these constraints to create an intuitive experience for connecting microcontrollers and peripherals. JACDAC devices communicate in a bus topology, which means devices can be connected in any order and at any point on the bus. Each device also has its own unique address which means that multiple of the same device can be connected without an addressing collision. What's more is that the software interface to each device is standardised, which means that like-functionality devices can take the place of one another at runtime without modifying application code.

## Protocol overview

A JACDAC device is any device that implements the JACDAC protocol. The protocol consists of three core layers:

1. (optional) The service layer––How JACDAC devices share hardware or software resources with one another.
2. The transport layer––Responsible for reliably routing packets to and from services and applications.
3. The physical layer––Transmits and receives packets from other JACDAC devices.

By design, the JACDAC protocol does not support allocation of unique device identifiers, which
must be [generated](./identifiers)

### Services

The way JACDAC devices share resources with other devices on the bus are through __services__. Services provide abstract, standardized interfaces that can be used to interact with physical hardware resources (e.g. an accelerometer) or pure virtual resources (e.g. the state of a video game). This abstraction brings plug-and-play dynamism to JACDAC so that devices with different hardware, but the same overall functionality, can replace one another without having to recompile user applications. For example, two different models of accelerometer hardware can replace each other because they share the same software interface. [Read more about Services](./services)

Any device that hosts a service must also run the control service. The control service is responsible for advertising any services a device is running every 500 milliseconds. Like any other service, the packets emitted by the control service are standardized. There also a set of common commands that must be implemented by JACDAC devices that operate services, including functionality like `reset` and `time since boot`.

No JACDAC device is required to operate a service. In fact, the major use case is for users to write applications that interact with JACDAC devices and services. Using JACDAC in microcontroller applications is incredibly easy and only requires a software stack that has a compatible JACDAC physical layer.

### Transport

Whenever a frame is received by the physical layer, the transport layer divides that frame into data packets and forwards them to the appropriate service or user application. At this point, services and applications can use packets to perform actions based on new data.

In many cases it is important that data is received by a specific device. JACDAC supports this mechanism using acknowledgements and pipes. Acknowledgements are incredibly simple and require receiving devices to recognise that a frame has successfully been received. Pipes on the other hand set up a point to point connection between devices, and every packet is acknowledge and received using a sliding window approach. Only the most capable devices are expected to support pipes.

[Read more about the transport layer.](./transport)

### Physical

In the future there will be many physical layer implementations responsible for sending frames across a wired or wireless communication medium. Frames contain one or more packets, and packets contain a service command or report. Frames also have addressing metadata embedded inside them that the transport layer uses to route packets correctly.

For communicating across a single wire, devices should observe the Single Wire Serial (SWS) communication standard. [Read more about the SWS standard here.](./sws-protocol)
