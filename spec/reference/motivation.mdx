---
title: Motivation
order: 0
---

## Motivation

For the longest time, microcontroller programming remained out of reach for the majority. Traditionally, embedded developers, with comprehensive knowledge of toolchains and software development practices, have been required to write programs for microcontrollers. But over the past decade, this has changed. Now all it takes to program a microcontroller is to load up a web-based environment like [Microsoft MakeCode](https://makecode.com), build your program using colourful visual blocks, and download the resulting program to your microcontroller. It is so easy _[everyone is doing it](https://cacm.acm.org/magazines/2020/3/243028-the-bbc-microbit-from-the-u-k-to-the-world/fulltext)_.

Though microcontroller programming has become easier, compared to the easy experience of connecting a device to a personal computer, it still remains a challenge to connect additional peripherals and sensors to microcontrollers. Here, an understanding of electronics and low level communications protocols are required, which means that again, only embedded developers can successfully do it. Of course, there are many instances of ecosystems and special connectors that have emerged to solve the complexity of connecting electronics. Arduino Shields, Raspberry Pi HATs, and the micro:bit edge connector, all make it easier for non-experts to connect additional hardware to microcontrollers. This style of connector however is often non-compositional and impractical where specific form factors are required. To give more physical flexibility, wired connectors and modular ecosystems are used instead. Grove, Stemma QT, and Gadgeteer all use easy to connect cables to make it easier to compose hardware. But there are additional constraints that only become apparent when communicating with newly connected hardware.

The changing use of microcontrollers by non-experts, means that now the wired communications protocols of the past in the 1980s are hindering the developers of the future. For example: I2C does not support having more than one controller on the bus at a time; I2C does not support multiples of the same sensor on a bus without additional hardware configuration; SPI requires an additional select line for each sensor/peripheral that is connected to the microcontroller; and moreover, each sensor is near-guaranteed to have different software interfaces even those with the same functionality. These are just a few examples of subtleties that make connecting additional peripherals to microcontrollers a hard-frought experience. <!-- of protocol addressing, specialised software interfaces, implied electrical connectivity, and constraints on physical topology -->

What we set out to achieve with JACDAC is to remove all of these constraints to create an intuitive experience for connecting microcontrollers and peripherals. JACDAC devices communicate in a bus topology, which means devices can be connected in any order and at any point on the bus. Each device also has its own unique address which means that multiple of the same device can be connected without an addressing collision. What's more is that the software interface to each device is standardised, which means that like-functionality devices can take the place of one another at runtime without modifying application code.
