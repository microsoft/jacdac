---
order: 4
title: Service Layer
---

# Service layer

The way JACDAC devices share resources with other devices on the bus are through __services__. Services provide abstract, standardised interfaces that can be used to interact with physical hardware resources (e.g. an accelerometer) or pure virtual resources (e.g. state of a video game). This abstraction brings plug-and-play dynamicity to JACDAC so that devices with different hardware, but the same overall functionality, can replace one another without having to recompile user applications. For example, two different  models of accelerometer hardware can replace each other because they share the same software interface.

Services act on __commands__ and optionally respond with __reports__. Reports can also be emitted separately from a service without prompting from another device. This interface is specified in a custom markdown language that lists the possible commands and reports a service can consume and emit. Specifications can also inherit from other specifications. A great example of this can be seen in the [sensor specification](../services/_sensor.md). JACDAC sensors inherit commands and reports from this specification, creating a set of base functionality for _all_ sensors.

## Commands

Commands are 16-bit and specified in the `service_command` field of a JACDAC packet. A command is composed of a 4-bit operation and a 12-bit code.

The operation is stored in the top most nibble of the `service_command` field. The following table below outlines all possible operations; XXX represents any 12-bit command code:

| Operation number | Command 	|
|--------|------------	|
| `0x0XXX` | Action	|
| `0x1XXX` | Register read	|
| `0x2XXX` | Register write	|
| `0x3XXX`- `0xfXXX` | Reserved	|

### Actions

Actions are a type of command that cause a service to begin to carry out a task. An example action might be to calibrate a magnetometer.

Services can freely allocate their own action command codes in the following range:

| Action code range | Purpose 	|
|--------|------------	|
| `0x080-0xeff` | Service defined action command codes 	|

However, services __must not__ allocate any of the common or reserved action command codes specified in the table below:

| Action code range | Purpose 	|
|--------|------------	|
| `0x000-0x07f` | Common action command codes	|
| `0xf00-0xfff` | Reserved action command codes	|

Common action command codes are allocated in the [base specification](../services/_base.md).

### Registers

Registers are properties that represent the state of a service.  Registers are variable length and are between 1 byte and 236 bytes (max payload) in size. Sequential register codes do not overlap with one another. For example, it is possible to have register `0x090` of size `12` and non-overlapping register `0x091` of size `4`.

Registers can be accessed and modified by register read (`0x1XXX`) and register write (`0x2XXX`) operations. Registers can be specified to be read-only or read-write capable. Trying to write to a read-only register will result in a nop (no operation). Because registers can have different access attributes they are segmented into different command code ranges.

Register command codes can be freely allocated in the following ranges:

| Register code range | Purpose 	|
|--------|------------	|
| `0x080-0x0ff` | Read-write register codes specific to a service	|
| `0x180-0x1ff` | Read-only register codes specific to a service	|
| `0x280-0x2ff` | Additional register codes specific to a service. Should generally be avoided.	|

However, services __must not__ allocate any of the common or reserved register command codes specified in the table below:

| Register code range | Purpose 	|
|--------|------------	|
| `0x001-0x07f` | Read-write registers common to all services	|
| `0x100-0x17f` | Read-only registers common to all services	|
| `0xf00-0xfff` | Reserved for future use.	|

Common register command codes are allocated in the [base specification](../services/_base.md).

### Reports

Reports are packets sent by a service as a response to a command. They can also be used to independently broadcast important information such as events.

Layout of a report changes depending on its end purpose. __Register reports__ must always contain the register values requested in the original command packet, but for actions, the format is left up to the service creator to define. __Actions reports__ can either contain a pre-determined number of bytes as defined in the service specification or bear no operation.

A third type of report is an __Event__. Events are emitted independently by a service without prompting by a device. Some services may offer an interface to configure which events are emitted. Unlike prior types of report, event reports have a fixed format:
(TODO: this is not true; these fields are 4 bytes)

| Memory offset | Field size (bytes) 	| Field name 	| Description  	|
|--------|------------	|-------------	|----------	|
| 16 | 2	|`event_id`	| A number that uniquely identifies an event. |
| 18 | 2	|`event_argument`	| An optional argument that can provide additional context.	|

Event reports are sent in the same way as any other packet, and `device_identifier`, `service_instance`, and `service_command` differentiate it from other types of reports. These differentiators provide a unique namespace for each service. Multiple event reports can be placed back-to-back inside a single packet as long as their `event_id` pertains to the same service. For example, a button can emit `UP` and `HOLD` events in the same packet.
(TODO: this is actually handled by multiple packets in frame)

## The control service

The design of the physical layer accommodates dynamic connectivity, services bring hardware abstraction, but the control service is responsible for dynamic device discovery. To achieve this, the control service emits advertisement packets roughly every 500 milliseconds. Each advertisement packet contains a list of host services offered by a device; other devices on the bus can inspect these advertisements and subsequently communicate with the advertised services to incorporate them in user applications.

The control service also offers a set of common commands that can be used to query/inspect each JACDAC device. For example, the `IDENTIFY` command causes a JACDAC device to perform an action that allows a user to locate a particular device, usually through blinking an LED. In addition to emiting an advertisement packet every 500 milliseconds, a device that hosts one or more services must respond to all commands listed in the [control service specification](../services/control.md).

Implementation complexity of the control service scales with respect to the number of services a device implements. For instance, it is very simple to process packets for a single user service (in addition to the control service), but complexity increases as more services are added. This flexibility is a benefit as it allows ultra low-cost microcontrollers to be used in simple devices.