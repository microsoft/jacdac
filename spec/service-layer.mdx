## Services

The way JACDAC devices share resources with other devices on the bus are through __services__. Services provide abstract, standardised interfaces that can be used to interact with physical hardware resources (e.g. an accelerometer) or pure virtual resources (e.g. distributed shared memory). This abstraction brings plug-and-play dynamicity to JACDAC so that devices with different hardware, but the same overall functionality, can replace one another without having to recompile user applications. For example, two different  models of accelerometer hardware can replace each other because they share the same software interface.

Services act on __commands__ and optionally respond with __reports__. Reports can also be emitted separately from a service without prompting from another device. This interface is specified in a custom markdown language that lists the possible commands and reports a service can consume and emit. Specifications can also inherit from other specifications. A great example of this can be seen in the [sensor specification](../services/_sensor.md). JACDAC sensors inherit commands and reports from this specification, creating a set of base functionality for _all_ sensors.

### Commands

Commands are 16-bit and specified in the `service_command` field of a JACDAC packet. A command is composed of a 4-bit operation and a 12-bit code.

The operation is stored in the top most nibble of the `service_command` field. The following table below outlines all possible operations; XXX represents any 12-bit command code:

| Operation number | Command 	|
|--------|------------	|
| `0x0XXX` | Action	|
| `0x1XXX` | Register read	|
| `0x2XXX` | Register write	|
| `0x3XXX`- `0xfXXX` | Reserved	|

#### Actions

Actions are a type of command that cause a service to begin to carry out a task. An example action might be to set the angle of a servo to 90 degrees.

Services can freely allocate their own action command codes in the following range:

| Action code range | Purpose 	|
|--------|------------	|
| `0x080-0xeff` | Service defined action command codes 	|

However, services __must not__ allocate any of the common or reserved action command codes specified in the table below:

| Action code range | Purpose 	|
|--------|------------	|
| `0x000-0x07f` | Common action command codes	|
| `0xf00-0xfff` | Reserved action command codes	|

Common action command codes are allocated to base specifications (e.g. the [sensor specification](../services/_sensor.md)). Any service that inherits from a base specification is expected to respond to command codes it specifies.

#### Registers

Registers are properties that represent the state of a service.  Registers are variable length and are between 1 byte and 236 bytes (max payload) in size. Sequential register codes do not overlap with one another. For example, it is possible to have register `0x090` of size `12` and non-overlapping register `0x091` of size `4`.

Registers can be accessed and modified by register read (`0x1XXX`) and register write (`0x2XXX`) operations. Registers can be specified to be read-only or read-write capable . Trying to write to a read-only register will result in a nop (no operation). Because registers can have different access attributes they are segmented into different command code ranges.

Register command codes can be freely allocated in the following ranges:

| Register code range | Purpose 	|
|--------|------------	|
| `0x080-0x0ff` | Read-write register codes specific to a service	|
| `0x180-0x1ff` | Read-only register codes specific to a service	|
| `0x280-0x2ff` | Additional register codes specific to a service. May be used in exceptional circumstances.	|

However, services __must not__ allocate any of the common or reserved register command codes specified in the table below:

| Register code range | Purpose 	|
|--------|------------	|
| `0x001-0x07f` | Read-write registers common to all services	|
| `0x100-0x17f` | Read-only registers common to all services	|
| `0xf00-0xfff` | Reserved for future use.	|

Common register command codes are allocated to base specifications (e.g. the [sensor specification](../services/_sensor.md)). Any service that inherits from a base specification is expected to implement and respond to the registers it specifies.

### Reports

Reports are packets sent by a service as a response to a command. They can also be used to independently broadcast important information such as events.

Report packet layout of a report changes depending on its end purpose. __Register reports__ must always contain the register values requested in the original command packet, but for actions, the format is left up to the service creator to define. __Actions reports__ can either contain a pre-determined number of bytes as defined in the service specification or bear no operation.

A third type of report is an __Event__. Events are emitted independently by a service without prompting by a device. Some services may offer an interface to configure which events are emitted. Unlike prior types of report, event reports have a fixed format:

| Memory offset | Field size (bytes) 	| Field name 	| Description  	|
|--------|------------	|-------------	|----------	|
| 16 | 2	|`event_id`	| A number that uniquely identifies an event. |
| 18 | 2	|`event_argument`	| An optional argument that can provide additional context.	|

Event reports are sent in the same way as any other packet, and `device_identifier`, `service_instance`, and `service_command` differentiate it from other types of reports. These differentiators provide a unique namespace for each service. Multiple event reports can be placed back-to-back inside a single packet as long as their `event_id` pertains to the same service. For example, a button can emit `UP` and `HOLD` events in the same packet.

## The control service

The design of the physical accomodates dynamic connectivity, services bring hardware abstraction, but the control service is responsible for dynamic device discovery. To achieve this, the control service emits advertisement packets roughly every 500 milliseconds. Each advertisement packet contains a list host services offered by a device; other devices on the bus can inspect these advertisements and subsequently communicate with them to incorporate them in user applications.

The control service also offers a set of common commands that can be used to query/inspect each JACDAC device. For example, the `IDENTIFY` command causes a JACDAC device to perform an action that allows a user to locate a particular device, usually through blinking an LED. In addition to emiting an advertisement packet every 500 milliseconds, a device that hosts one or more services must respond to all commands listed in the [control service specification](../services/control.md).

Implementation complexity of the control service scales with respect to the number of services a device implements. For instance, it is very simple to process packets for a single user service (in addition to the control service), but complexity increases as more services are added. This flexibility is a benefit as it allows ultra low-cost microcontrollers to be used in simple devices.